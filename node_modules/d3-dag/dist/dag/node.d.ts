/**
 * A [[Dag]] is simply a collection of [[DagNode]]s, defined by every reachable
 * child node from the current returned node.  If a DAG contains multiple
 * roots, then the returned node will be a [[DagRoot]] that links to all nodes.
 * Each child node on its own will function as a valid DAG with a single root.
 * All DAGs are also iterators over all of their nodes.
 *
 * Three methods exist to turn existing data into [[Dag]]s:
 * 1. [["dag/hierarchy" | dagHierarchy]] - when the data already has a dag structure.
 * 2. [["dag/stratify" | dagStratify ]] - when the dag has a tabular structure, referencing parents by id.
 * 3. [["dag/connect" | dagConnect ]] - when the dag has a link structure and is specified as pairs of nodes.
 *
 * Methods names preceeded by an `i` will return a [[FluentIterable]] which is
 * a wrapper around native EMCA iterators that also adds most methods found in
 * the `Array` prototype making them much more useful for fluent functional
 * programming.
 *
 * @packageDocumentation
 */
import { FluentIterable } from "../iters";
/** @internal */
export declare class LayoutChildLink<LinkDatum, NodeType extends DagNode<unknown, LinkDatum>> {
    readonly child: NodeType;
    data: LinkDatum;
    points: {
        x: number;
        y: number;
    }[];
    constructor(child: NodeType, data: LinkDatum, points?: {
        x: number;
        y: number;
    }[]);
}
/**
 * The concrete class backing the [[Link]] interface.
 */
export declare class LayoutLink<NodeType extends DagNode> {
    readonly source: NodeType;
    readonly target: NodeType;
    readonly data: NodeType["dataChildren"][0]["data"];
    readonly points: {
        x: number;
        y: number;
    }[];
    constructor(source: NodeType, target: NodeType, data: NodeType["dataChildren"][0]["data"], points: {
        x: number;
        y: number;
    }[]);
}
/**
 * The concreate implementation of [[DagNode]], this forwards most calls to a
 * singleton [[LayoutDagRoot]] with the exception of children methods, as
 * [[DagRoot]]s don't have children.
 */
export declare class LayoutDagNode<NodeDatum, LinkDatum> {
    readonly id: string;
    data: NodeDatum;
    dataChildren: ChildLink<LinkDatum, this>[];
    value?: number;
    constructor(id: string, data: NodeDatum);
    /** An iterator of this node. */
    iroots(): FluentIterable<this>;
    /** An array of this node. */
    roots(): this[];
    private iterChildren;
    /** An iterator of this node's children. */
    ichildren(): FluentIterable<this>;
    /** An array of this node's children. */
    children(): this[];
    private iterChildLinks;
    /** An iterator of links between this node and its children. */
    ichildLinks(): FluentIterable<Link<this>>;
    /** An array of links between this node and its children. */
    childLinks(): Link<this>[];
    [Symbol.iterator](): Iterator<this>;
    idescendants(style?: IterStyle): FluentIterable<this>;
    descendants(style?: IterStyle): this[];
    ilinks(): FluentIterable<Link<this>>;
    links(): Link<this>[];
    size(): number;
    sum(callback: (node: this, index: number) => number): this & ValuedNode;
    count(): this & ValuedNode;
    height(): this & ValuedNode;
    depth(): this & ValuedNode;
    split(): this[];
    connected(): true;
}
/**
 * The concrete implementation backing [[DagRoot]] which also contains the
 * implementation of most methods in [[DagNode]].
 */
export declare class LayoutDagRoot<NodeType extends DagNode> implements Iterable<NodeType> {
    dagRoots: NodeType[];
    constructor(dagRoots: NodeType[]);
    [Symbol.iterator](): Iterator<NodeType>;
    /**
     * This returns an iterator over every root in the [[Dag]]. Since
     * [[DagNode]]s return themselves for this call, this can be an easy way to
     * turn a [[Dag]] into an array of [[DagNode]]s.
     */
    iroots(): FluentIterable<NodeType>;
    /** Returns an array of roots. */
    roots(): NodeType[];
    private idepth;
    private ibreadth;
    private ibefore;
    private iafter;
    /**
     * Returns an iterator over all descendants of this node, e.g. every node in
     * the [[Dag]]. An [[IterStyle]] can be passed in to influence the iteration
     * order, the default (`'depth'`) should generally be the fastest, but note
     * that in general, traversal in a DAG takes linear space as we need to track
     * what nodes we've already visited.
     *
     * - 'depth' - starting from the left most root, visit a nodes left most
     *   child, progressing down to children before yielding any other node.
     * - 'breadth' - starting from the left most root, yield each of it's
     *   children, before yielding the children of its left most child.
     * - 'before' - yield all of the roots, progressing downward, never yielding
     *   a node before all of its parents have been yielded.
     * - 'after' - yield all leaf nodes, progressing upward, never yielding a
     *   node before all of its parents have been yielded.
     */
    idescendants(style?: IterStyle): FluentIterable<NodeType>;
    /** Returns an array of [[idescendants]]. */
    descendants(style?: IterStyle): NodeType[];
    /** Returns an iterator over every [[Link]] in the DAG. */
    ilinks(): FluentIterable<Link<NodeType>>;
    /** Returns an array of [[ilinks]]. */
    links(): Link<NodeType>[];
    /** Counts the number of nodes in the DAG. */
    size(): number;
    /**
     * Provide a callback that computes a number for each node, then set a node's
     * value to the sum of this number for this node and all of its descendants.
     *
     * This method returns [[ValuedNode]]s that also have a value property.
     */
    sum(callback: (node: NodeType, index: number) => number): DagRoot<NodeType & ValuedNode>;
    /**
     * Set the value of each node to be the number of leaves beneath the node.
     * If this node is a leaf, its value is one.
     *
     * This method returns [[ValuedNode]]s that also have a value property.
     */
    count(): DagRoot<NodeType & ValuedNode>;
    /**
     * Assign each node a value equal to its longest distance from a root.
     *
     * This method returns [[ValuedNode]]s that also have a value property.
     */
    height(): DagRoot<NodeType & ValuedNode>;
    /**
     * Assign each node a value equal to its longest distance to a leaf.
     *
     * This method returns [[ValuedNode]]s that also have a value property.
     */
    depth(): DagRoot<NodeType & ValuedNode>;
    /**
     * Returns an array of connected DAGs, splitting the DAG into several
     * components if its dosconnected.
     */
    split(): Dag<NodeType>[];
    /**
     * Return true if every node in the dag is reachable from every other.
     */
    connected(): boolean;
}
/** All available styles of node iteration. */
declare type IterStyle = "depth" | "breadth" | "before" | "after";
/** A mixin for when a node is assigned a value property by a method. */
export interface ValuedNode {
    value: number;
}
/** @internal */
export declare type ChildLink<LinkDatum, NodeType extends DagNode<unknown, LinkDatum> = DagNode<unknown, LinkDatum>> = LayoutChildLink<LinkDatum, NodeType>;
/** The public facing interface backed by the [[LayoutLink]] implementation. */
export declare type Link<NodeType extends DagNode = DagNode> = LayoutLink<NodeType>;
/** The public facing interface backed by the [[LayoutDagNode]] implementation. */
export declare type DagNode<NodeDatum = unknown, LinkDatum = unknown> = LayoutDagNode<NodeDatum, LinkDatum>;
/** The public facing interface backed by the [[LayoutDagRoot]] implementation. */
export declare type DagRoot<NodeType extends DagNode = DagNode> = LayoutDagRoot<NodeType>;
/**
 * The union of a [[DagNode]] and [[DagRoot]], representing the return value of
 * a Dag constructor. Since the interface between [[DagNode]]s and [[DagRoot]]s
 * is almost identical, this union is mostly inconsequential, and all methods
 * can be fond within [[LayoutDagRoot]].
 */
export declare type Dag<NodeType extends DagNode = DagNode> = NodeType | DagRoot<NodeType>;
export {};
