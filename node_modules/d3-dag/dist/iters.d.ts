declare type OfAble<T> = Iterator<T> | Iterable<T>;
declare class LazyFluentIterable<T> implements Iterable<T> {
    private readonly base;
    constructor(base: Iterable<T>);
    [Symbol.iterator](): Iterator<T, undefined, undefined>;
    concat(...others: OfAble<T>[]): FluentIterable<T>;
    entries(): FluentIterable<[number, T]>;
    every(callback: (element: T, index: number) => boolean): boolean;
    fill<S>(val: S): FluentIterable<S>;
    filter(callback: (element: T, index: number) => boolean): FluentIterable<T>;
    find(callback: (element: T, index: number) => boolean): T | undefined;
    findIndex(callback: (element: T, index: number) => boolean): number;
    flatMap<S>(callback: (element: T, index: number) => OfAble<S>): FluentIterable<S>;
    forEach(callback: (element: T, index: number) => void): void;
    includes(query: T, fromIndex?: number): boolean;
    indexOf(query: T, fromIndex?: number): number;
    join(separator?: string): string;
    keys(): FluentIterable<number>;
    lastIndexOf(query: T, fromIndex?: number): number;
    get length(): number;
    map<S>(callback: (element: T, index: number) => S): FluentIterable<S>;
    reduce(callback: (accumulator: T, currentValue: T, index: number) => T): T;
    reduce<S>(callback: (accumulator: S, currentValue: T, index: number) => S, initialValue: S): S;
    reverse(): FluentIterable<T>;
    slice(start?: number, end?: number): FluentIterable<T>;
    some(callback: (element: T, index: number) => boolean): boolean;
    sort(compare?: (first: T, second: T) => number): FluentIterable<T>;
    splice(start: number, deleteCount?: number, ...items: T[]): FluentIterable<T>;
    values(): FluentIterable<T>;
}
export declare type FluentIterable<T> = LazyFluentIterable<T>;
export declare function fluent<T>(seq: OfAble<T>): FluentIterable<T>;
export {};
